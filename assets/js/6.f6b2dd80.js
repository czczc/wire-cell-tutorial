(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{358:function(e,a,t){e.exports=t.p+"assets/img/flow-simple.40a09406.png"},359:function(e,a,t){e.exports=t.p+"assets/img/flow-full.840a9aa5.png"},380:function(e,a,t){"use strict";t.r(a);var s=t(44),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"examine-program-flow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examine-program-flow"}},[e._v("#")]),e._v(" Examine Program Flow")]),e._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#dump-configurations"}},[e._v("Dump configurations")])]),s("li",[s("a",{attrs:{href:"#visualize-pgraph"}},[e._v("Visualize pgraph")])])])]),s("p"),e._v(" "),s("p",[e._v("Wire-Cell follows the "),s("em",[e._v("dataflow programming")]),e._v(" paradigm that models a program as a "),s("em",[e._v("directed graph")]),e._v(" of data flow between operations. The dataflow graph is defined by a top-level jsonnet file. For instance, in the previous "),s("a",{attrs:{href:"explore-data"}},[e._v('"Explore Real Data"')]),e._v(" example, Wire-Cell executed "),s("a",{attrs:{href:"https://github.com/WireCell/wire-cell-cfg/blob/master/pgrapher/experiment/pdsp/Quickstart/raw-to-sig.jsonnet",target:"_blank",rel:"noopener noreferrer"}},[e._v("this jsonnet file"),s("OutboundLink")],1),e._v(" to perform the entire signal processing chain on ProtoDUNE-SP raw data.")]),e._v(" "),s("h2",{attrs:{id:"dump-configurations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dump-configurations"}},[e._v("#")]),e._v(" Dump configurations")]),e._v(" "),s("p",[e._v("We can visualize the dataflow graph, called "),s("a",{attrs:{href:"https://github.com/WireCell/wire-cell-cfg/tree/master/pgrapher",target:"_blank",rel:"noopener noreferrer"}},[e._v("pgraph"),s("OutboundLink")],1),e._v(" in Wire-Cell, to better understand how the program runs. First, we can dump all the configuration into a single "),s("em",[e._v("json")]),e._v(" file")]),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("jsonnet -V "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("reality")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("data -V "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("raw_input_label")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("daq "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n    -J cfg cfg/pgrapher/experiment/pdsp/Quickstart/raw-to-sig.jsonnet "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n    -o a.json\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("The output "),s("code",[e._v("a.json")]),e._v(" is a huge JSON file that contains all the pgraph and configuration parameters. It may be difficult to read. Certain tools such as "),s("a",{attrs:{href:"https://stedolan.github.io/jq/",target:"_blank",rel:"noopener noreferrer"}},[e._v("jq"),s("OutboundLink")],1),e._v(" can be used to parse the JSON file at command line. In the following, we use another tool "),s("code",[e._v("wirecell-pgraph")]),e._v(" to visualize the pgraph.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("The "),s("code",[e._v("-V")]),e._v(" option to "),s("code",[e._v("jsonnet")]),e._v(" command specifies the values of external variables defined in the jsonnet file by "),s("code",[e._v("std.extVar()")]),e._v(". These variables are not set in the jsonnet file itself, but must be passed in by external programs.")])]),e._v(" "),s("h2",{attrs:{id:"visualize-pgraph"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#visualize-pgraph"}},[e._v("#")]),e._v(" Visualize pgraph")]),e._v(" "),s("p",[e._v("The "),s("code",[e._v("wirecell-pgraph")]),e._v(" tool relies on the "),s("code",[e._v("graphviz")]),e._v(" package, so do "),s("code",[e._v("sudo apt install graphviz")]),e._v(" if it's not installed.\nAssuming that you have followed "),s("RouterLink",{attrs:{to:"/quickstart/explore-data.html#_3d-imaging-experimental"}},[e._v("the previous instruction")]),e._v(" to setup your python virtual environment called "),s("code",[e._v("wcpy")]),e._v(". Inside the wcpy environment, do")],1),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("wirecell-pgraph dotify --jpath -1 --no-params a.json flow-simple.pdf\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v(", which produces the following dataflow graph")]),e._v(" "),s("p",[s("img",{attrs:{src:t(358),alt:"flow-simple"}})]),e._v(" "),s("p",[e._v("Ignoring the several "),s("em",[e._v("Magnifysink")]),e._v(" nodes which outputs ROOT histograms for debugging, this graph is rather simple and clearly show how the data from 6 APAs are fanned out to be processed individually with the "),s("em",[e._v("OminbusNoisefilter")]),e._v(" and "),s("em",[e._v("OminbusSigProc")]),e._v(" nodes, and merged back into the stream after signal processing.")]),e._v(" "),s("p",[e._v("If you omit the "),s("code",[e._v("--no-params")]),e._v(" option, the output will also contain all the configuration parameter values, resulting a much detailed graph useful for debugging:")]),e._v(" "),s("p",[s("img",{attrs:{src:t(359),alt:"flow-simple"}})])])}),[],!1,null,null,null);a.default=r.exports}}]);